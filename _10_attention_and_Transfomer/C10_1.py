#注意力机制#这一节主要是绘制softmax(QK_T)矩阵的热力图#创建一个softmax(QK_T)矩阵#数据一般为batch_size * head_num * seq_len * seq_len,其实这里简化成seq_len * seq_len即可#这里的可视化函数show_heatmap仅接收seq_len * seq_len矩阵，后续多次用到import torchimport torch.nn as nndef show_heatmap(attention_weights, title='Attention Weights Heatmap', add_num=False, cmap='Reds'):    """    绘制注意力权重矩阵的热力图    attention_weights: torch.Tensor, 形状为 [seq_len1, seq_len2] 或 [batch_size, seq_len1, seq_len2]    title: 图的标题    add_num: 是否在图上显示数值    cmap: 颜色映射，默认'Reds'    """    import matplotlib.pyplot as plt    import numpy as np    # 确保是numpy数组    if hasattr(attention_weights, 'detach'):        weights = attention_weights.detach().numpy()    else:        weights = np.array(attention_weights)    # 如果输入是3D张量，只显示第一个样本    if weights.ndim == 3:        print(f"输入是3D张量，形状为 {weights.shape}，将显示第一个样本")        weights = weights[0]    # 获取矩阵的两个维度    seq_len1, seq_len2 = weights.shape    # 获取数据的最大值和最小值    data_min = np.min(weights)    data_max = np.max(weights)    # 如果数据范围很小，使用数据范围作为vmin和vmax    # 否则使用0-1的范围（因为softmax结果在0-1之间）    if data_max - data_min < 0.1:  # 如果数据范围很小        vmin = data_min        vmax = data_max        # 为了确保有足够的颜色对比，可以稍微扩展范围        vmin = max(0, vmin - (vmax - vmin) * 0.1)        vmax = min(1, vmax + (vmax - vmin) * 0.1)    else:        vmin = 0        vmax = 1    # 创建热力图    fig, ax = plt.subplots(figsize=(8, 6))    im = ax.imshow(weights, cmap=cmap, vmin=vmin, vmax=vmax, aspect='auto')    # 添加颜色条    cbar = ax.figure.colorbar(im, ax=ax)    cbar.ax.set_ylabel('Attention Weight', rotation=-90, va="bottom")    # 设置标题和标签    ax.set_title(title)    ax.set_xlabel('Key Position')    ax.set_ylabel('Query Position')    # 设置刻度 - 分别处理两个维度    def get_ticks_and_labels(seq_len, max_ticks=20):        """根据序列长度自动生成刻度和标签"""        if seq_len <= max_ticks:            ticks = list(range(seq_len))            labels = [str(i) for i in ticks]            return ticks, labels        # 计算合适的步长        step = max(1, seq_len // max_ticks)        # 调整到更人性化的步长        for factor in [2, 5, 10]:            if step <= factor:                step = factor                break        ticks = list(range(0, seq_len, step))        if seq_len - 1 not in ticks:            ticks.append(seq_len - 1)        labels = [str(i) for i in ticks]        return ticks, labels    # 获取两个维度的刻度和标签    x_ticks, x_labels = get_ticks_and_labels(seq_len2)    y_ticks, y_labels = get_ticks_and_labels(seq_len1)    # 设置刻度    ax.set_xticks(x_ticks)    ax.set_yticks(y_ticks)    ax.set_xticklabels(x_labels)    ax.set_yticklabels(y_labels)    # 添加网格线    ax.grid(False)    # 添加数值标签(可选，当矩阵较大时不建议添加）    if add_num and seq_len1 <= 30 and seq_len2 <= 30:        for i in range(seq_len1):            for j in range(seq_len2):                # 根据数值大小动态调整文本颜色                value = weights[i, j]                # 使用归一化的值来决定文本颜色                normalized_value = (value - vmin) / (vmax - vmin) if vmax != vmin else 0.5                text_color = "white" if normalized_value > 0.5 else "black"                # 根据数值大小决定显示格式                if abs(data_max - data_min) < 0.01:  # 如果数据范围很小，显示更多小数位                    text = f'{value:.4f}'                elif abs(data_max - data_min) < 0.1:  # 中等范围，显示3位小数                    text = f'{value:.3f}'                else:  # 正常范围，显示2位小数                    text = f'{value:.2f}'                ax.text(j, i, text, ha="center", va="center", color=text_color, fontsize=8)    plt.tight_layout()    plt.show()    # 打印信息供参考    print(f"矩阵形状: ({seq_len1}, {seq_len2})")    print(f"数据范围: [{data_min:.6f}, {data_max:.6f}]")    print(f"使用的颜色映射范围: [{vmin:.6f}, {vmax:.6f}]")def show_multiple_heatmaps(data_list, figsize=(10, 6), layout=None,                           title=None, hide_ticks=False, filename=None):    """    在同一画布上绘制多个热力图，支持隐藏刻度线和保存图像    参数:    data_list: 元组列表，每个元组格式为 (attention_weights, title, add_num, cmap)               其中 attention_weights: 注意力权重张量                   title: 子图标题 (可选)                   add_num: 是否显示数值 (可选)                   cmap: 颜色映射 (可选)    figsize: 整体图形尺寸    layout: 子图布局 (rows, cols)，如果为None则自动计算    title: 整个图像的标题（可选）    hide_ticks: 是否隐藏刻度线（默认为False）    filename: 保存图像的文件名（可选，如果提供则保存图像）    示例:    data = [        (attention_weights[0], 'Sample 1', True, 'Reds'),        (attention_weights[1], 'Sample 2', False, 'Blues'),        (attention_weights[2], 'Sample 3', True, 'Greens')    ]    show_multiple_heatmaps(data, title='Attention Weights', hide_ticks=True)    """    import matplotlib.pyplot as plt    import numpy as np    n = len(data_list)    # 自动计算布局    if layout is None:        if n <= 2:            rows, cols = 1, n        elif n <= 4:            rows, cols = 2, 2        elif n <= 6:            rows, cols = 2, 3        elif n <= 9:            rows, cols = 3, 3        else:            rows, cols = (n + 2) // 3, 3    else:        rows, cols = layout    # 调整图形尺寸    fig_width = figsize[0] * (cols / 2)    fig_height = figsize[1] * (rows / 2)    fig, axes = plt.subplots(rows, cols, figsize=(fig_width, fig_height))    # 设置整个图像的标题    if title is not None:        fig.suptitle(title, fontsize=16, fontweight='bold', y=1.02)    # 处理单个子图的情况    if rows == 1 and cols == 1:        axes = np.array([[axes]])    elif rows == 1:        axes = axes.reshape(1, -1)    elif cols == 1:        axes = axes.reshape(-1, 1)    # 绘制每个子图    for idx, data_item in enumerate(data_list):        row = idx // cols        col = idx % cols        if row >= rows:            break  # 如果数据太多，只显示前 rows*cols 个        ax = axes[row, col]        # 解析数据        if len(data_item) == 1:            weights, sub_title, add_num, cmap = data_item[0], f'Plot {idx + 1}', False, 'Reds'        elif len(data_item) == 2:            weights, sub_title = data_item            add_num, cmap = False, 'Reds'        elif len(data_item) == 3:            weights, sub_title, add_num = data_item            cmap = 'Reds'        else:            weights, sub_title, add_num, cmap = data_item        # 转换为numpy数组        if hasattr(weights, 'detach'):            weights_np = weights.detach().numpy()        else:            weights_np = np.array(weights)        # 如果输入是3D张量，取第一个样本        if weights_np.ndim == 3:            weights_np = weights_np[0]        # 获取矩阵形状        seq_len1, seq_len2 = weights_np.shape        # 获取数据范围        data_min = np.min(weights_np)        data_max = np.max(weights_np)        # 设置颜色范围        if data_max - data_min < 0.1:            vmin = max(0, data_min - (data_max - data_min) * 0.1)            vmax = min(1, data_max + (data_max - data_min) * 0.1)        else:            vmin = 0            vmax = 1        # 绘制热力图        im = ax.imshow(weights_np, cmap=cmap, vmin=vmin, vmax=vmax, aspect='auto')        # 添加颜色条        from mpl_toolkits.axes_grid1 import make_axes_locatable        divider = make_axes_locatable(ax)        cax = divider.append_axes("right", size="5%", pad=0.05)        plt.colorbar(im, cax=cax)        # 设置子图标题        if sub_title:            ax.set_title(f'{sub_title} ({seq_len1}×{seq_len2})')        else:            ax.set_title(f'({seq_len1}×{seq_len2})')        # 设置轴标签（如果隐藏刻度线，也隐藏轴标签）        if not hide_ticks:            ax.set_xlabel('Key')            ax.set_ylabel('Query')        # 处理刻度线        if hide_ticks:            # 隐藏所有刻度线和标签            ax.set_xticks([])            ax.set_yticks([])            ax.set_xticklabels([])            ax.set_yticklabels([])        else:            # 设置刻度标签            def get_ticks_and_labels(seq_len, max_ticks=10):                if seq_len <= max_ticks:                    return list(range(seq_len)), [str(i) for i in range(seq_len)]                step = max(1, seq_len // max_ticks)                for factor in [2, 5, 10]:                    if step <= factor:                        step = factor                        break                ticks = list(range(0, seq_len, step))                if seq_len - 1 not in ticks:                    ticks.append(seq_len - 1)                labels = [str(i) for i in ticks]                return ticks, labels            # 设置刻度标签            x_ticks, x_labels = get_ticks_and_labels(seq_len2, max_ticks=8)            y_ticks, y_labels = get_ticks_and_labels(seq_len1, max_ticks=8)            ax.set_xticks(x_ticks)            ax.set_yticks(y_ticks)            ax.set_xticklabels(x_labels)            ax.set_yticklabels(y_labels)        # 添加数值标签        if add_num and not hide_ticks and seq_len1 <= 15 and seq_len2 <= 15:            for i in range(seq_len1):                for j in range(seq_len2):                    value = weights_np[i, j]                    normalized_value = (value - vmin) / (vmax - vmin) if vmax != vmin else 0.5                    text_color = "white" if normalized_value > 0.5 else "black"                    if abs(data_max - data_min) < 0.01:                        text = f'{value:.4f}'                    elif abs(data_max - data_min) < 0.1:                        text = f'{value:.3f}'                    else:                        text = f'{value:.2f}'                    ax.text(j, i, text, ha="center", va="center",                            color=text_color, fontsize=7)    # 隐藏多余的子图    for idx in range(n, rows * cols):        row = idx // cols        col = idx % cols        axes[row, col].axis('off')    plt.tight_layout()    # 保存图像（如果提供了文件名）    if filename is not None:        # 确保文件扩展名是.png（或者支持其他格式）        if not filename.lower().endswith(('.png', '.jpg', '.jpeg', '.pdf', '.svg')):            filename += '.png'        plt.savefig(filename, dpi=300, bbox_inches='tight')        print(f"图像已保存为: {filename}")    plt.show()# 使用示例if __name__ == "__main__":    import torch    # 生成测试数据    attention_weights = []    for i in range(6):        seq_len1 = torch.randint(3, 10, (1,)).item()        seq_len2 = torch.randint(3, 15, (1,)).item()        weights = torch.randn(seq_len1, seq_len2)        weights = torch.softmax(weights, dim=-1)        attention_weights.append(weights)    # 创建数据列表    data = [        (attention_weights[0], 'Sample 1', True, 'Reds'),        (attention_weights[1], 'Sample 2', False, 'Blues'),        (attention_weights[2], 'Sample 3', True, 'Greens'),        (attention_weights[3], 'Sample 4', False, 'Purples'),        (attention_weights[4], 'Sample 5', True, 'Oranges'),        (attention_weights[5], 'Sample 6', False, 'gray')    ]    # 绘制多个热力图    show_multiple_heatmaps(data, figsize=(18, 12))    # 也可以使用部分参数    data_simple = [        (attention_weights[0], 'First'),        (attention_weights[1], 'Second'),        (attention_weights[2])  # 只传张量，使用默认标题    ]    show_multiple_heatmaps(data_simple)if __name__ == '__main__':    seq_len = 10    X = nn.functional.softmax(torch.randn((seq_len, seq_len), device='cpu'))    # 确保对角线元素是最大值    for i in range(X.shape[0]):        # 找到最大值位置        max_pos = torch.argmax(X[i, :])        # 交换对角线元素和最大值元素        X[i, i], X[i, max_pos] = X[i, max_pos].clone(), X[i, i].clone()    show_heatmap(X)